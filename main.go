package main

import (
	"DeployBot/awslex"
	"DeployBot/mattermostapi"
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/lexruntimeservice"
	"github.com/mattermost/mattermost-server/model"
)

var client *model.Client

func basicAuth(project string) string {
	var username string = "user1"
	var passwd string = "abcdef"
	client := &http.Client{}
	req, err := http.NewRequest("POST", "http://18.219.168.27:8080/job/"+project+"/build", nil)
	req.SetBasicAuth(username, passwd)
	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	bodyText, err := ioutil.ReadAll(resp.Body)
	s := string(bodyText)
	return s
}

func basicStatus(project string) (string, string) {

	var username string = "user1"
	var passwd string = "abcdef"
	client := &http.Client{}
	req, err := http.NewRequest("GET", "http://18.219.168.27:8080/job/"+project+"/lastBuild/api/json", nil)
	req.SetBasicAuth(username, passwd)
	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	bodyText, err := ioutil.ReadAll(resp.Body)

	type AutoGenerated struct {
		Class   string `json:"_class"`
		Actions []struct {
			Class  string `json:"_class,omitempty"`
			Causes []struct {
				Class            string `json:"_class"`
				ShortDescription string `json:"shortDescription"`
				UserID           string `json:"userId"`
				UserName         string `json:"userName"`
			} `json:"causes,omitempty"`
		} `json:"actions"`
		Artifacts         []interface{} `json:"artifacts"`
		Building          bool          `json:"building"`
		Description       interface{}   `json:"description"`
		DisplayName       string        `json:"displayName"`
		Duration          int           `json:"duration"`
		EstimatedDuration int           `json:"estimatedDuration"`
		Executor          interface{}   `json:"executor"`
		FullDisplayName   string        `json:"fullDisplayName"`
		ID                string        `json:"id"`
		KeepLog           bool          `json:"keepLog"`
		Number            int           `json:"number"`
		QueueID           int           `json:"queueId"`
		Result            string        `json:"result"`
		Timestamp         int64         `json:"timestamp"`
		URL               string        `json:"url"`
		BuiltOn           string        `json:"builtOn"`
		ChangeSet         struct {
			Class string        `json:"_class"`
			Items []interface{} `json:"items"`
			Kind  interface{}   `json:"kind"`
		} `json:"changeSet"`
		Culprits []interface{} `json:"culprits"`
	}

	var rs AutoGenerated
	if err = json.Unmarshal(bodyText, &rs); err != nil {
		log.Fatal(err)
	}

	println(string(bodyText))
	println(rs.Number)
	return rs.Result, string(rs.Number)
}

func main() {

	//go controller.Start()
	mm := &mattermostapi.MatterMost{
		Url:         "http://18.219.168.27:8065",
		UserName:    "bot",
		Password:    "12345",
		TeamName:    "chatbot",
		ChannelName: "DevopsBot",
	}

	client := mm.GetClient()

	log.Println(" Channle Id in main " + mm.ChannelId)
	webSocketClient, err := model.NewWebSocketClient4("ws://18.219.168.27:8065", client.AuthToken)
	if err != nil {
		println("We failed to connect to the web socket")
		log.Fatal(err)
	}

	

	webSocketClient.Listen()

	go func() {
		for {
			select {
			case resp := <-webSocketClient.EventChannel:
				HandleResponse(resp, mm)
			}
		}
	}()

	sigterm := make(chan os.Signal, 1)
	signal.Notify(sigterm, syscall.SIGTERM)
	signal.Notify(sigterm, syscall.SIGINT)
	<-sigterm

}

func HandleResponse(event *model.WebSocketEvent, mc *mattermostapi.MatterMost) {

	//log.Println("HandleResponse - " + event.Broadcast.ChannelId)
	if event.Broadcast.ChannelId != mc.ChannelId {
		return
	}
	if event.Event != model.WEBSOCKET_EVENT_POSTED {
		return
	}

	//println("responding to message in channel ", mc.ChannelName)

	//log.Println("responding to debugging channel msg")

	postedmessage := model.PostFromJson(strings.NewReader(event.Data["post"].(string)))

	if postedmessage != nil {

		if postedmessage.UserId == mc.UserId {
			return
		}

		ProcessMessage(postedmessage, mc)

	}

}

func contains(slice []string, item string) bool {
	set := make(map[string]struct{}, len(slice))
	for _, s := range slice {
		set[s] = struct{}{}
	}
	_, ok := set[item]
	return ok
}

func ProcessMessage(postedmessage *model.Post, mc *mattermostapi.MatterMost) {

	log.Println("Posted message for - " + postedmessage.Message + " by user " + postedmessage.UserId)
	res, _ := mc.GetClient().GetUser(postedmessage.UserId, mc.GetClient().Etag)
	username := res.Data.(*model.User).GetFullName()
	input := new(lexruntimeservice.PostTextInput)
	input.SetBotAlias("devopsbot")
	input.SetBotName("devopsbot")
	input.SetInputText(postedmessage.Message)
	input.SetUserId(
		postedmessage.UserId)
	mySession, _ := session.NewSession(&aws.Config{
		Region: aws.String("eu-west-1")})

	output, _ := awslex.GetLexOutput(input, mySession)
	dialogstate := aws.StringValue(output.DialogState)

	log.Println("Dialog state ", dialogstate)
	log.Println("message " + aws.StringValue(output.Message))
	log.Println("message " + aws.StringValue(output.IntentName))
	switch dialogstate {
	case "ConfirmIntent":

		if aws.StringValue(output.IntentName) == "CreateITSMIntent" {
			log.Println("Creating an ITSM for the user")
			mc.PostMessage(mc.GetClient(), "Please review itsm details")
			message := "appname = " + aws.StringValue(output.SessionAttributes["appname"])
			mc.PostMessage(mc.GetClient(), message)
			message = "environment = " + aws.StringValue(output.SessionAttributes["environment"])
			mc.PostMessage(mc.GetClient(), message)
			mc.PostMessage(mc.GetClient(), "ITSM Date = "+aws.StringValue(output.Slots["date"]))
			mc.PostMessage(mc.GetClient(), "Description = "+aws.StringValue(output.Slots["description"]))
			mc.PostMessage(mc.GetClient(), aws.StringValue(output.Message))
		}
	case "Fulfilled":

		if aws.StringValue(output.IntentName) == "help" {
			mc.PostMessage(mc.GetClient(), username+" -  "+aws.StringValue(output.Message))

		}
		if aws.StringValue(output.IntentName) == "DeploymentIntent" {

			configuredProjs := []string{"starbucks", "timhortons", "dunkindonuts"}
			appname := aws.StringValue(output.Slots["appname"])
			if !contains(configuredProjs, appname) {
				mc.PostMessage(mc.GetClient(), "Invalid application name, please start over and make sure to give correct appname ")
			} else {
				mc.PostMessage(mc.GetClient(), aws.StringValue(output.Message))
				log.Println("Trying to call the jenkins")
				_ = basicAuth(appname)
				result, number := basicStatus(appname)
				retrunUrl := "http://18.219.168.27:8080/job/" + appname + "/" + number
				if result == "" {
					result = "In Progress"
				}
				mc.PostMessage(mc.GetClient(), "The build URL is "+retrunUrl)
				mc.PostMessage(mc.GetClient(), "The build status is "+result)
			}
		}
		break
	case "ElicitIntent":
		mc.PostMessage(mc.GetClient(), username+" - "+aws.StringValue(output.Message))
		break
	case "ElicitSlot":
		mc.PostMessage(mc.GetClient(), username+" -  "+aws.StringValue(output.Message))
		break
	case "ReadyForFulfillment":
		intent := aws.StringValue(output.IntentName)
		log.Println("intent name " + intent)
		messageToSend := BackendLogic(output, intent, mc)
		log.Println("AppName " + aws.StringValue(output.Slots["App"]))
		mc.PostMessage(mc.GetClient(), username+" - "+messageToSend)
		break

	}
}

func BackendLogic(out *lexruntimeservice.PostTextOutput, intent string, mc *mattermostapi.MatterMost) string {

	inputs := out.Slots
	switch intent {
	case "DeploymentIntent":
		log.Println("AppName " + aws.StringValue(inputs["appname"]))
		return "Scheduled deployent for " + aws.StringValue(inputs["appname"]) + " in " + aws.StringValue(inputs["environment"])

	case "DeploytoProdintent":

	case "CreateITSMIntent":
		log.Println("Creating an ITSM for the user")
		mc.PostMessage(mc.GetClient(), "Succesfully created ITSM - ABCD1234")
		return ""

	case "Schedules":

		return "Scheduled Deployment at 10 PM"

	default:
		mc.PostMessage(mc.GetClient(), aws.StringValue(out.Message))

	}

	return ""
}
